//
//  SquarePenTest.cpp
//  Assignment2
//
//  Created by Jared Barfknecht on 9/12/17.
//  Copyright Â© 2017 Jared Barfknecht. All rights reserved.
//

#include <stdio.h>
#include "TestHarness.h"
#include "ICanvas.hpp"
#include "BasicCanvas.hpp"
#include "Color.hpp"
#include "IStroke.hpp"
#include "SquareStroke.hpp"
#include "IPen.hpp"
#include "SquarePen.hpp"
#include "WindowsBitmapEncoder.hpp"
#include "WindowsBitmapDecoder.hpp"

using namespace BitmapGraphics;

TEST(draw1x1Point, SquarePen)
{
    Color pixelToSet{255, 0, 0};
    
    SquareStroke stroke(1, pixelToSet);
    HPen hPen{new SquarePen(stroke)};
    
    Color backColor{255, 255, 255};
    HCanvas hCanvas{new BasicCanvas(10, 10, backColor)};
    
    /* drawing red point to first pixel within last row of Bitmap
       which is stored with bottom ScanLine first */
    hPen->drawPoint(hCanvas, VG::Point(0, 0));
    
    HBitmapIterator canvasIterator = hCanvas->createBitmapIterator();
    
    WindowsBitmapEncoder encoderPrototype{};
    HBitmapEncoder encoder{encoderPrototype.clone(canvasIterator)};
    
    // Write out the bitmap
    std::ofstream outputStream{"Square1x1PenDrawing.bmp", std::ios::binary};
    CHECK(outputStream.is_open());
    
    encoder->encodeToStream(outputStream);
    outputStream.close();
    
    // Read that one back in
    std::ifstream bitmapStream{"Square1x1PenDrawing.bmp", std::ios::binary};
    CHECK(bitmapStream.is_open());
    
    WindowsBitmapDecoder decoderPrototype{};
    HBitmapDecoder decoder{decoderPrototype.clone(bitmapStream)};
    auto bitmapIter = decoder->createIterator();
    
    // Confirm red pixel is first point
    CHECK_EQUAL(true, pixelToSet == bitmapIter->getColor());
    bitmapIter->nextPixel();
    
    // The rest should be background color
    while(!bitmapIter->isEndOfImage())
    {
        while(!bitmapIter->isEndOfScanLine())
        {
            CHECK_EQUAL(true, backColor == bitmapIter->getColor());
            bitmapIter->nextPixel();
        }
        
        bitmapIter->nextScanLine();
    }
}

TEST(draw3x3Point, SquarePen)
{
    Color pixelToSet{255, 0, 0};
    
    SquareStroke stroke(3, pixelToSet);
    HPen hPen{new SquarePen(stroke)};
    
    Color backColor{255, 255, 255};
    HCanvas hCanvas{new BasicCanvas(10, 10, backColor)};
    
    /* drawing 3x3 red square to first pixels within last
       three rows of Bitmap which is stored with bottom
       ScanLine first */
    hPen->drawPoint(hCanvas, VG::Point(0, 0));
    
    HBitmapIterator canvasIterator = hCanvas->createBitmapIterator();
    
    WindowsBitmapEncoder encoderPrototype{};
    HBitmapEncoder encoder{encoderPrototype.clone(canvasIterator)};
    
    // Write out the bitmap
    std::ofstream outputStream{"Square3x3PenDrawing.bmp", std::ios::binary};
    CHECK(outputStream.is_open());
    
    encoder->encodeToStream(outputStream);
    outputStream.close();
    
    // Read that one back in
    std::ifstream bitmapStream{"Square3x3PenDrawing.bmp", std::ios::binary};
    CHECK(bitmapStream.is_open());
    
    WindowsBitmapDecoder decoderPrototype{};
    HBitmapDecoder decoder{decoderPrototype.clone(bitmapStream)};
    auto bitmapIter = decoder->createIterator();
    
    // Confirm 3x3 red square is in top of canvas
    int scanLineIndex = 0;
    while(scanLineIndex != 3)
    {
        int pixelIndex = 0;
        
        // these three in a row should be the pixel we set
        while(pixelIndex != 3)
        {
            CHECK_EQUAL(true, pixelToSet == bitmapIter->getColor());
            bitmapIter->nextPixel();
            ++pixelIndex;
        }
        
        // the rest should be the background color
        while(!bitmapIter->isEndOfScanLine())
        {
            CHECK_EQUAL(true, backColor == bitmapIter->getColor());
            bitmapIter->nextPixel();
        }
        
        bitmapIter->nextScanLine();
        ++scanLineIndex;
    }
}

/* confirm drawing mechanic safely ignores requests to draw off
   of canvas */
TEST(drawOffCanvas, SquarePen)
{
    Color pixelToSet{255, 0, 0};
    
    SquareStroke stroke(3, pixelToSet);
    HPen hPen{new SquarePen(stroke)};
    
    Color backColor{255, 255, 255};
    HCanvas hCanvas{new BasicCanvas(10, 10, backColor)};
    
    /* attempt to draw 3x3 red square starting at end of scanLine.
       Points outside canvas should be ignored */
    hPen->drawPoint(hCanvas, VG::Point(9, 0));
    
    HBitmapIterator canvasIterator = hCanvas->createBitmapIterator();
    
    WindowsBitmapEncoder encoderPrototype{};
    HBitmapEncoder encoder{encoderPrototype.clone(canvasIterator)};
    
    // Write out the bitmap
    std::ofstream outputStream{"SquareOffCanvasPenDrawing.bmp", std::ios::binary};
    CHECK(outputStream.is_open());
    
    encoder->encodeToStream(outputStream);
    outputStream.close();
    
    // Read that one back in
    std::ifstream bitmapStream{"SquareOffCanvasPenDrawing.bmp", std::ios::binary};
    CHECK(bitmapStream.is_open());
    
    WindowsBitmapDecoder decoderPrototype{};
    HBitmapDecoder decoder{decoderPrototype.clone(bitmapStream)};
    auto bitmapIter = decoder->createIterator();
    
    /* The last pixel of the first three lines should be the set pixel
       The rest should be the background color */
    int scanLineIndex = 0;
    
    while(scanLineIndex != 3)
    {
        int pixelIndex = 0;
        while(pixelIndex != 9)
        {
            CHECK_EQUAL(true, backColor == bitmapIter->getColor());
            bitmapIter->nextPixel();
            ++pixelIndex;
        }

        // last pixel should be the color we set
        while(!bitmapIter->isEndOfScanLine())
        {
            CHECK_EQUAL(true, pixelToSet == bitmapIter->getColor());
            bitmapIter->nextPixel();
        }

        bitmapIter->nextScanLine();
        ++scanLineIndex;
    }

    // the rest should be the background color
    while(!bitmapIter->isEndOfImage())
    {
        while(!bitmapIter->isEndOfScanLine())
        {
            CHECK_EQUAL(true, backColor == bitmapIter->getColor());
            bitmapIter->nextPixel();
        }
        
        bitmapIter->nextScanLine();
    }
}
